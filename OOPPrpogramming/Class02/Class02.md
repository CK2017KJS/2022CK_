<h1>객체지향프로그래밍 고급</h1>

#
<h3>문법 복습(?) or Morden C++ 문법들</h3>

- auto 문
    ```c
        auto Def(int A,int B){
            return A+B;
        }
    ```
- Array 
    
    Legarcy Array 
    ```c
        int A[] ={} //등등의 형식
    ```

    std::Array
    ```c
        //std::array->
        array<int,3>
    ```

    
#

<h3> Codeing Style (?)</h3>

- 바람직한 Codeing Style

    -문서화

    > ```c
    >//OpenDataBase() 를 먼저 호출해야 합니다. 
    >int SaveRecotd(Record& record); 
    >```

        코드만으로 표현이 힘든 내용들을 자연어로 표현
            사용법
            호출 조건,선행조건
            예외처리/예외
            Public 메서드에는 꼭 남기도록 하자.

    -분할
    
    -명명 규칙

    >```c
    > //컴파일러 규칙- 첫글자에 숫자 금지.. 등등 컴파일러에서 강제하는 명명
    >   int n1,n2; //<-이렇게 짜면 밥 굶어야 함
    >   char char123; // 준말 사용하기 ㄴㄴ
    >   char Char_To_123 //대소문자 + 언더바 조합..?
    >   #define NONE_DATA 0// 상수는 보통 완전 대문자로 정리하던데..
    >   
    >   //보통 미리 명명 규칙이 정의되어 있음. 
    >   //컴파일러가 자료형을 알려주므로 헝가리안 표기법은 사장되는 추세
    >   //상수는 꼭 const던 Define 이던 미리 표기해줄 것
    >   const float GravityPower = 9.8f
    >   //
    >```
    
    -언어적 스타일
    
        포인터->레퍼런스로 바꿀수 있으면 바꾸는게 맞고..
        nullptr 앵간하면 사용하지 않기(nullptr을 가르키면 보통 좆망함)
        except는 케바케지만 .. 당연히 쓸 일이 없게 검사하는게 제일 좋겠지..? 
        
        (파이썬은 예외처리 한번 할때마다 수천번?이상 느려진다고 하더라 ..)
    
    -언어 사용
    
    -포매팅
    
    ``` c

        if(b<a)
        {
            ClassA = new Class(123);

            if(a=!b)
            {
                func();
                func2(Class);
            }

        }
    ```

    ```c
        if(b<a){
            ClassA = new Class(123);
            if(a=!b){
                func();
                func2(Class);
            }
        }
    ```

    협업하다 이런 포매팅 안 맞추면 싸움 ㅆㄱㄴ


- const

        가능하자면 모든 곳에 const를 쓰자.
        (치트엔진같은 외부 메모리 조작에도 const로 고정시키는 방법이 유효함. const를 사용한다면 프로그램 곳곳으로 퍼져나가는게 맞다..)


- 디자인 패턴
    
        잘못 작성하기 힘들게 작성
        
        냉정하게 프로그램 구현이 어렵진 않지 않은가?
        가독성을 좀 더 우선시 하자...
        건물 세우기와 같아서 나중에 고치려면 비용(시간,자원)이 많이 든다.

<h1>    
- 하면 안되는 짓들
</h1>

-   같은 코드 중복 = 캡슐화 , 구조화 안 됨
-   긴 메소드, 방대한 클래스 

    >때에 따라 다르지만 OOP의 개념적으로 생각해 볼 때,
    >하나의 거대한 클래스의 경우는 좋지 않은 경우가 많다.

-   하나의 클래스 변경이 다른 클래스에 관여

    >내가 자주 하던 실수인데,
    >총이 플레이어의 포인터를 가지고 있다던가..
    >레이어가 씬의 정보를 가지고 있다던가..

-   기능에 대한 욕심(?)

    >요약하자면 클래스간 데이터의 월권.
    >다른 객체에 접근하거나 하는 경우..

    진짜 자주 일어난 일인데 ..
    
    A와 B가 충돌할 경우, 각자의 충돌 처리를
    A와 B 각각에서 처리하는게 맞지만
    무심코 A에서 B의 값을 바꾼다던지의 대한 정보를 건드린다던가.. 의 ... 유니티나 Win32만져본 사람들은 다 알잖아요 ..
